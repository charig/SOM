MultiByteFileStream = StandardFileStream (
	"The central class to access the external file.  The interface of this object is similar to good old StandardFileStream, but internally it asks the converter, which is a sub-instance of TextConverter, and do the text conversion.  It also combined the good old CrLfFileStream.  CrLfFileStream class>>new now returns an instance of MultiByteFileStream.  There are several pitfalls:  * You always have to be careful about the binary/text distinction.  In #text mode, it usually interpret the bytes.  * A few file pointer operations treat the file as uninterpreted byte no matter what.  This means that if you use 'fileStream skip: -1', 'fileStream position: x', etc. in #text mode, the file position can be in the middle of multi byte character.  If you want to implement some function similar to #peek for example, call the saveStateOf: and restoreStateOf: methods to be able to get back to the original state.  * #lineEndConvention: and #wantsLineEndConversion: (and #binary) can cause some puzzling situation because the inst var lineEndConvention and wantsLineEndConversion are mutated.  If you have any suggestions to clean up the protocol, please let me know."
	| converter lineEndConvention wantsLineEndConversion |
	
	basicNext: anInteger putAll: aCollection startingAt: startIndex = (
		^super next: anInteger putAll: aCollection startingAt: startIndex
	)
	
	setConverterForCode = (
		| current |
		(SourceFiles at: 2)
			ifNotNil: [self fullName = (SourceFiles at: 2) fullName ifTrue: [^ self]].
		current := self converter saveStateOf: self.
		self position: 0.
		self binary.
		"Check what to do with hexadecimal literals
		((self next: 3) = #[ 16rEF 16rBB 16rBF ]) ifTrue: [
			self converter: UTF8TextConverter new
		] ifFalse: [
			self converter: MacRomanTextConverter new.
		]."
		converter restoreStateOf: self with: current.
		self text.
	
	)
	
	basicNext: anInteger = (
		^ super next: anInteger.
	
	)
	
	converter: aConverter = (
		converter := aConverter.
		self installLineEndConventionInConverter
	
	)
	
	basicNextPut: char = (
		^ super nextPut: char.
	
	)
	
	binary = (
		super binary.
		self lineEndConvention: nil
	)
	
	lineEndConvention: aSymbol = (
		(lineEndConvention := aSymbol) ifNotNil: [wantsLineEndConversion := true].
		self installLineEndConventionInConverter
	)
	
	peekFor: item = (
		| next state |
		state := converter saveStateOf: self.
		(next := self next) == nil ifTrue: [^ false].
		item = next ifTrue: [^ true].
		converter restoreStateOf: self with: state.
		^ false.
	)
	
	basicReadInto: byteArray startingAt: startIndex count: count = (
		^ super readInto: byteArray startingAt: startIndex count: count.
	
	)
	
	basicChunk = (
		"If our buffer in collection contains an chunk with no embedded !'s, nor
		any non-ascii characters, return that.
		This presumes the source code encoding is unambiguously ascii-compatible"
		| bufferIX goodString |
		"Not possible if read buffering disabled"
		collection ifNil: [^nil].
		^ ((bufferIX := (collection indexOf: '!' startingAt: position + 1) min: readLimit + 1) > 0
				and: [bufferIX < collection size
						and: [(collection at: bufferIX + 1)
									~= '!'
								and: [goodString := collection copyFrom: position + 1 to: bufferIX - 1.
									goodString isAsciiString]]])
			ifTrue: [ position := bufferIX.
					goodString]
	)
	
	ascii = (
		super ascii.
		self detectLineEndConvention.
	
	)
	
	basicUpTo: delim = (
		^ super upTo: delim.
	)
	
	requestDropStream: dropIndex = (
		"Needs to install proper converter"
		
		| result |
		result := super requestDropStream: dropIndex.
		result ifNotNil: [
			converter ifNil: [self converter: UTF8TextConverter new].
			lineEndConvention ifNil: [ self detectLineEndConvention] ].
		^result
	)
	
	next: n innerFor: aString = (
	
		| peekChar state |
		"if we just read a CR, and the next character is an LF, then skip the LF"
		aString size = 0 ifTrue: [^ aString].
		(aString last = Character cr) ifTrue: [
			state := converter saveStateOf: self.
			peekChar := self bareNext.		"super peek doesn't work because it relies on #next"
			(peekChar notNil and: [peekChar ~= Character lf]) ifTrue: [
				converter restoreStateOf: self with: state.
			].
		].
	 
		^ aString withSqueakLineEndings.
	
	)
	
	peek = (
		"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "
	
		| next save |
		self atEnd ifTrue: [^ nil].
		save := converter saveStateOf: self.
		next := self next.
		converter restoreStateOf: self with: save.
		^ next.
	
	
	)
	
	open: fileName forWrite: writeMode = (
		| result |
		result := super open: fileName forWrite: writeMode.
		result ifNotNil: [
				converter ifNil: [self converter: UTF8TextConverter new].
				lineEndConvention ifNil: [ self detectLineEndConvention ]
		].
		^result
	)
	
	wantsLineEndConversion = (
	
		^wantsLineEndConversion == true
	
	)
	
	installLineEndConventionInConverter = (
	
		converter ifNotNil: [
			converter installLineEndConvention: (
				(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"
					ifTrue: [ LineEndStrings at: lineEndConvention ]
					ifFalse: [ nil ]) ]
	)
	
	bareNext = (
	
		 ^ self converter nextFromStream: self.
	
	)
	
	basicVerbatim: aString = (
	
		^ super verbatim: aString.
	
	)
	
	reset = (
	
		super reset.
		converter ifNil: [
			self converter: UTF8TextConverter new.
		].
	
	)
	
	next: anInteger = (
	
	
		| multiString |
		self isBinary ifTrue: [^ super next: anInteger].
		multiString := String new: anInteger.
		1 to: anInteger do: [:index |
			| character |
			(character := self next)
				ifNotNil: [ multiString at: index put: character ]
				ifNil: [
					multiString := multiString copyFrom: 1 to: index - 1.
					(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"
						ifFalse: [ ^multiString ].
					^self next: anInteger innerFor: multiString ] ].
		(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"
			 ifFalse: [ ^multiString ].
	
		multiString := self next: anInteger innerFor: multiString.
		(multiString size = anInteger or: [self atEnd]) ifTrue: [ ^ multiString].
		^ multiString, (self next: anInteger - multiString size).
	
	)
	
	upToAnyOf: delimiters do: aBlock = (
	
		^self collectionSpecies new: 1000 streamContents: [ :stream |
			| ch |
			[ (ch := self next) == nil or: [ (delimiters includes: ch) and: [aBlock value: ch. true] ] ] 
				whileFalse: [ stream nextPut: ch ] ]
	)
	
	nextMatchAll: aColl = (
	
	    | save |
	    save := converter saveStateOf: self.
	    aColl do: [:each |
	       (self next) = each ifFalse: [
	            converter restoreStateOf: self with: save.
	            ^ false.
			].
		].
	    ^ true.
	
	)
	
	basicPosition = (
	
		^ super position.
	
	)
	
	detectLineEndConvention = (
		"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."
		| char numRead state |
		self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].
		wantsLineEndConversion == true ifFalse: [self lineEndConvention: nil.
						^lineEndConvention].
		self closed ifTrue: [self lineEndConvention: LineEndDefault.
						^lineEndConvention].
	
		"Default if nothing else found"
		numRead := 0.
		state := self converter saveStateOf: self.
		lineEndConvention := nil.
		[super atEnd not and: [numRead < LookAheadCount]]
			whileTrue: 
				[char := self next.
				char = Lf
					ifTrue: 
						[converter restoreStateOf: self with: state.
						self lineEndConvention: #lf.
						^lineEndConvention].
				char = Cr
					ifTrue: 
						[self peek = Lf
							ifTrue: [self lineEndConvention: #crlf]
							ifFalse: [self lineEndConvention: #cr].
						converter restoreStateOf: self with: state.
						^ lineEndConvention].
				numRead := numRead + 1].
		converter restoreStateOf: self with: state.
		self lineEndConvention: LineEndDefault.
		^ lineEndConvention
	)
	
	next: anInteger putAll: aCollection startingAt: startIndex = (
	
	
	        (self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [
	                ^super next: anInteger putAll: aCollection startingAt: startIndex ].
	        ^self converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self
	)
	
	basicSkip: n = (
	
		^ super skip: n.
	
	)
	
	lineEndConvention = (
	
		^lineEndConvention
	)
	
	converter = (
	
		converter ifNil: [self converter: TextConverter defaultSystemConverter].
		^ converter
	
	)
	
	next = (
	
		| char secondChar state |
		char := (converter ifNil: [ self converter ]) nextFromStream: self.
		(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"
			 ifTrue: [
				char == Cr ifTrue: [
					state := converter saveStateOf: self.
					secondChar := self bareNext.
					secondChar ifNotNil: [
						secondChar == Lf ifFalse: [ converter restoreStateOf: self with: state ] ].
					^Cr ].
				char == Lf ifTrue: [
					^Cr ] ].
		^char.
	
	
	)
	
	basicSetToEnd = (
	
		^ super setToEnd.
	
	)
	
	skipSeparators = (
	
		| state character |
		[ 
			state := converter saveStateOf: self.
			(character := self next) 
				ifNil: [ false ]
				ifNotNil: [ character isSeparator ] ] whileTrue.
		character ifNotNil: [ 
			converter restoreStateOf: self with: state ]
	)
	
	wantsLineEndConversion: aBoolean = (
		
		wantsLineEndConversion :=  aBoolean.
	
		lineEndConvention ifNil: [ self detectLineEndConvention ]. 
	)
	
	skipSeparatorsAndPeekNext = (
		"Same as #skipSeparators, but returns the next character after the separators if such exists."
	
		| state character |
		[ 
			state := converter saveStateOf: self.
			(character := self next) 
				ifNil: [ false ]
				ifNotNil: [ character isSeparator ] ] whileTrue.
		character ifNotNil: [ 
			converter restoreStateOf: self with: state.
			^character ].
		
	)
	
	basicPosition: pos = (
	
		^ super position: pos.
	
	)
	
	nextPutAll: aCollection = (
		^ (self isBinary or: [ aCollection class == ByteArray ])
			ifTrue: [ super nextPutAll: aCollection ]
			ifFalse: [ self converter nextPutAll: aCollection toStream: self ]
	)
	
	nextDelimited: terminator = (
	
		| out ch save |
		out := (String new: 1000) writeStream.
		self atEnd ifTrue: [^ ''].
		save := converter saveStateOf: self.
	
		self next = terminator ifFalse: [
			"absorb initial terminator"
			converter restoreStateOf: self with: save.
		].
		[(ch := self next) == nil] whileFalse: [
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					^ out contents  "terminator is not doubled; we're done!"
				].
			].
			out nextPut: ch.
		].
		^ out contents.
	
	)
	
	convertStringFromCr: aString = (
	
		| inStream outStream |
		lineEndConvention ifNil: [^ aString].
		lineEndConvention == #cr ifTrue: [^ aString].
		lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].
		"lineEndConvention == #crlf"
		inStream := aString readStream.
		outStream :=  (String new: aString size) writeStream.
		[inStream atEnd]
			whileFalse: 
				[outStream nextPutAll: (inStream upTo: Cr).
				(inStream atEnd not or: [aString last = Cr])
					ifTrue: [outStream nextPutAll: CrLf]].
		^ outStream contents
	)
	
	basicNextPutAll: aString = (
	
		^ super nextPutAll: aString.
	
	)
	
	accepts: aSymbol = (
	
	 	^ converter accepts: aSymbol.
	
	)
	
	doConversion = (
	
		^wantsLineEndConversion == true and: [ lineEndConvention notNil ]
	)
	
	basicPeek = (
	
		^ super peek
	
	)
	
	basicNext: n into: aString = (
	
		^ super next: n into: aString.
	
	)
	
	nextPut: aCharacter = (
		aCharacter isInteger 
			ifTrue: [ ^ super nextPut: aCharacter ].
		(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"
			 ifTrue: [
				aCharacter = Cr
					ifTrue: [ converter nextPutAll: (LineEndStrings at: lineEndConvention) toStream: self ]
					ifFalse: [ converter nextPut: aCharacter toStream: self ].
				^aCharacter ].
		^ self converter nextPut: aCharacter toStream: self
	
	)
	
	nextChunk = (
		"Answer the contents of the receiver, up to the next terminator
		character. Doubled terminators indicate an embedded terminator
		character."
		self skipSeparators.
		^ self
			parseLangTagFor: (self basicChunk
					ifNil: [String
							new: 1000
							streamContents: [:stream | 
								| character state |
								[(character := self next) == nil
									or: [character == '!'
											and: [state := converter saveStateOf: self.
												self next ~~ '!']]]
									whileFalse: [stream nextPut: character].
								character
									ifNotNil: [converter restoreStateOf: self with: state.]]])
	)
	
	basicNextInto: aString = (
	
		^ super nextInto: aString.
	
	)
	
	upTo: delimiter = (
	
		^self collectionSpecies new: 1000 streamContents: [ :stream |
			| ch |
			[ (ch := self next) == nil or: [ ch = delimiter ] ] 
				whileFalse: [ stream nextPut: ch ] ]
	
	)
	
	convertStringToCr: aString = (
		| inStream outStream |
		lineEndConvention ifNil: [^ aString].
		lineEndConvention == #cr ifTrue: [^ aString].
		lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Lf with: Cr].
		"lineEndConvention == #crlf"
		inStream := aString readStream.
		outStream := (String new: aString size) writeStream.
		[inStream atEnd]
			whileFalse: 
				[outStream nextPutAll: (inStream upTo: Cr).
				(inStream atEnd not or: [aString last = Cr])
					ifTrue: 
						[outStream nextPut: Cr.
						inStream peek = Lf ifTrue: [inStream next]]].
		^ outStream contents
	)
	
	upToEnd = (
	
		^self collectionSpecies
			new: self size - self position
			streamContents: [ :stream |
				| element |
				[ (element := self next) == nil ] whileFalse: [
					stream nextPut: element ] ]
	
	)
	
	readInto: buffer startingAt: offset count: requestedCount = (
		"Read up to requestedCount elements into the given buffer starting at offset.
		Return the number of elements actually read.
		If I am binary or if buffer is a ByteArray, I skip decoding. Yes this is weird.
		This is a necessarily inefficient implementation, reading and decoding characters one by one."
	
		(self isBinary or: [ buffer class == ByteArray ])
			ifTrue: [ ^ super readInto: buffer startingAt: offset count: requestedCount ].
		0 to: requestedCount - 1 do: [ :count | 
			| element |
			(element := self next) ifNil: [ ^ count ].
			buffer at: offset + count put: element ].
		^ requestedCount
	)
	
	fileInEncodingName: aString = (
	
		self converter: (TextConverter newForEncoding: aString).
		super fileIn.
	
	)
	
	----------------------------------
	| Cr CrLf Lf LineEndDefault LineEndStrings LookAheadCount |
	
	initialize = (
		"MultiByteFileStream initialize"
		Cr := Character cr.
		Lf := Character lf.
		CrLf := String with: Cr with: Lf.
		LineEndStrings := Dictionary new.
		LineEndStrings at: #cr put: (String with: Character cr).
		LineEndStrings at: #lf put: (String with: Character lf).
		LineEndStrings at: #crlf put: (String with: Character cr with: Character lf).
		LookAheadCount := 2048.
		Smalltalk addToStartUpList: self.
		self startUp.
	
	)
	
	defaultToCRLF = (
		"MultiByteFileStream defaultToCRLF"
		LineEndDefault := #crlf.
	)
	
	lineEndDefault = (
		"Answer the default line-ending convention that will be used by default, which was determined at start-up by looking at platform attributes."
		^ LineEndDefault
	)
	
	guessDefaultLineEndConvention = (
		"Lets try to guess the line end convention from what we know about the
		path name delimiter from FileDirectory."
		
		FileSystem disk delimiter = ':'
			ifTrue: [^ self defaultToCR].
			
		FileSystem disk delimiter = '$'
			ifTrue: [^ (Smalltalk os isMacOSX or: [Smalltalk os isUnix])
					ifTrue: [ self defaultToLF]
					ifFalse: [ self defaultToCR]].
				
		FileSystem disk delimiter = '\\'
			ifTrue: [^ self defaultToCRLF].
			
		"in case we don't know"
		^ self defaultToCR
	)
	
	defaultToLF = (
		"MultiByteFileStream defaultToLF"
		LineEndDefault := #lf.
	)
	
	newFrom: aFileStream = (
		| rw n |
		n := aFileStream name.
		rw := aFileStream isReadOnly not.
		aFileStream close.
		^self new open: n forWrite: rw.
	)
	
	startUp = (
		self guessDefaultLineEndConvention.
	)
	
	defaultToCR = (
		"MultiByteFileStream defaultToCR"
		LineEndDefault := #cr.
	)
)